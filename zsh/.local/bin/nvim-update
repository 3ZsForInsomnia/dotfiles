#!/usr/bin/env python3

import json
import os
import re
import shutil
import subprocess
import sys
import traceback
from argparse import ArgumentParser
from datetime import datetime, timezone
from pathlib import Path


# --- XDG Directories ---
def get_xdg_var(var, fallback):
    val = os.environ.get(var)
    if val:
        return Path(val)
    # Fallback for STATE_HOME is ~/.local/state, for CONFIG_HOME is ~/.config
    if fallback.startswith("~"):
        return Path.home() / fallback[2:]
    return Path(fallback)


STATE_DIR = get_xdg_var("XDG_STATE_HOME", "~/.local/state") / "nvim-update"
STATE_DIR.mkdir(parents=True, exist_ok=True)
HISTORY_FILE = STATE_DIR / "version-history.json"
BACKUP_DIR = STATE_DIR / "nvim-backups"
BACKUP_DIR.mkdir(parents=True, exist_ok=True)
LOG_FILE = STATE_DIR / "nvim-update.log"
MAX_LOG_SIZE = 5 * 1024 * 1024  # 5MB

# --- Settings ---
XDG_CODE_HOME = os.environ.get("XDG_CODE_HOME")
if not XDG_CODE_HOME:
    print("Environment variable XDG_CODE_HOME is not set.", file=sys.stderr)
    sys.exit(1)
NVIM_SRC = Path(XDG_CODE_HOME) / "neovim"
NVIM_INSTALL = Path(XDG_CODE_HOME) / "neovim"


# --- Logging ---
def logmsg(*args, prefix="[INFO]"):
    # Only write to log file, not stdout
    try:
        with open(current_logfile, "a") as fp:
            print(prefix, *args, file=fp)
            fp.flush()  # Ensure immediate write
    except Exception as e:
        print(
            f"[LOG ERROR] Failed to write to log file {current_logfile}: {e}",
            file=sys.stderr,
        )
        import traceback

        traceback.print_exc()


def logerr(*args):
    logmsg(*args, prefix="[ERROR]")


def logexc(e):
    details = traceback.format_exc()
    logerr(f"[EXCEPTION] {str(e)}\n{details}")


def start_log():
    try:
        # Check if log file needs rotation
        if LOG_FILE.exists() and LOG_FILE.stat().st_size > MAX_LOG_SIZE:
            old_log = STATE_DIR / "nvim-update.log.old"
            if old_log.exists():
                old_log.unlink()
            LOG_FILE.rename(old_log)

        # Write session marker to log
        now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        with open(LOG_FILE, "a") as fp:
            fp.write(f"\n=== Session started at {now} ===\n")
            fp.flush()

        return LOG_FILE
    except Exception as e:
        print(
            f"[CRITICAL] Failed to initialize log file in {STATE_DIR}: {e}",
            file=sys.stderr,
        )
        import traceback

        traceback.print_exc()
        # Fallback to a temp file
        import tempfile

        now_str = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M%S")
        fallback = Path(tempfile.gettempdir()) / f"nvim-update-{now_str}.log"
        print(f"[DEBUG] Using fallback log file: {fallback}", file=sys.stderr)
        with open(fallback, "a") as fp:
            fp.write(f"\n=== Session started at {now} (FALLBACK) ===\n")
        return fallback


current_logfile = str(start_log())


def backup_nvim(sha):
    nvim_bin = NVIM_INSTALL / "bin" / "nvim"
    backup_bin = BACKUP_DIR / f"nvim-{sha}"
    if nvim_bin.exists():
        shutil.copy2(nvim_bin, backup_bin)
        logmsg(f"Backed up nvim binary to {backup_bin}")
        return backup_bin.exists()
    else:
        logerr(f"nvim binary not found at {nvim_bin}")
        return False


def restore_nvim(sha):
    nvim_bin = NVIM_INSTALL / "bin" / "nvim"
    backup_bin = BACKUP_DIR / f"nvim-{sha}"
    if backup_bin.exists():
        shutil.copy2(backup_bin, nvim_bin)
        logmsg(f"Restored nvim binary from {backup_bin}")
    else:
        logerr(f"No backup found for SHA {sha} at {backup_bin}")


def run(cmd, check=True, capture_output=False, env=None):
    """Run a shell command, raising error if it fails."""
    logmsg(f"Running: {' '.join(cmd)}")
    try:
        completed = subprocess.run(
            cmd,
            check=check,
            capture_output=capture_output,
            text=True,
            env=env,
        )
        if capture_output:
            return completed.stdout.strip()
        return None
    except subprocess.CalledProcessError as e:
        logexc(e)
        logerr(f"Command failed: {' '.join(cmd)}")
        raise


def get_installed_nvim_sha():
    try:
        output = run([str(NVIM_INSTALL / "bin/nvim"), "--version"], capture_output=True)
        # Look for a pattern like 'g82f08f33c1' in the first line
        if not output:
            return None
        first_line = output.splitlines()[0]
        m = re.search(r"g([0-9a-f]{7,})", first_line)
        if m:
            return m.group(1)
        return None
    except Exception as e:
        logexc(e)
        return None


def get_sha():
    """Get current commit SHA and its date."""
    # Format: SHA and date in ISO format
    output = run(
        ["git", "show", "-s", "--format=%h|%ci", "HEAD"],
        capture_output=True,
    )
    if output:
        sha, date = output.split("|", 1)
        return sha, date.strip()
    else:
        return None, None


def get_remote_nightly_sha():
    """Get the SHA of the nightly tag from GitHub without checking it out."""
    try:
        # Fetch latest tags from origin
        run(["git", "fetch", "--tags", "--force"], check=False)
        # Get the SHA that the nightly tag points to
        output = run(
            ["git", "rev-parse", "--short", "nightly"],
            capture_output=True,
        )
        return output if output else None
    except Exception as e:
        logexc(e)
        return None


def git_checkout(ref):
    run(["git", "checkout", ref], check=True)


def remove_build():
    build = NVIM_SRC / "build"
    if build.exists():
        logmsg(f"Removing build dir: {build}")
        run(["rm", "-rf", str(build)])


def build_and_install():
    cmake_flags = [
        f"-DCMAKE_INSTALL_PREFIX={NVIM_INSTALL}",
        "-DCMAKE_BUILD_TYPE=RelWithDebInfo",
    ]
    env = os.environ.copy()
    # Run cmake configuration step
    run(["cmake", "-S", ".", "-B", "build"] + cmake_flags, env=env)
    # Build
    run(["cmake", "--build", "build", "--target", "install"], env=env)
    logmsg(f"Completed build/install to {NVIM_INSTALL}")


# --- Version History & Rollback ---
def load_history():
    if HISTORY_FILE.exists():
        try:
            with open(HISTORY_FILE, "r") as fp:
                return json.load(fp)
        except Exception as e:
            logexc(e)
            return []
    return []


def save_history(history):
    try:
        with open(HISTORY_FILE, "w") as fp:
            json.dump(history, fp, indent=2)
        logmsg(f"Saved version history ({len(history)} entries)")
    except Exception as e:
        logexc(e)
        logerr("Failed to save version history!")


def add_history_entry(tag, sha, action):
    history = load_history()
    ts = datetime.utcnow().isoformat() + "Z"
    entry = {"timestamp": ts, "tag": tag, "sha": sha, "action": action}
    if history and history[-1]["sha"] == sha:
        # Don't repeat
        return
    history.append(entry)
    save_history(history)


def print_history():
    history = load_history()
    for idx, h in enumerate(history):
        print(f"{idx}: [{h['timestamp']}] {h['action']} {h['tag']} ({h['sha']})")


def last_history():
    history = load_history()
    return history[-1] if history else None


def prev_history():
    history = load_history()
    return history[-2] if len(history) > 1 else None


# --- Core actions ---
def upgrade():
    try:
        logmsg("Deleting local tags 'nightly' and 'stable' if they exist...")
        run(["git", "tag", "-d", "nightly"])
        run(["git", "tag", "-d", "stable"])

        logmsg("Fetching latest origin & tags...")
        run(["git", "fetch", "--no-tags", "origin"])
        run(["git", "fetch", "--tags", "--force"])

        logmsg("Checking out latest 'nightly' tag...")
        run(["git", "checkout", "nightly"])

        sha_repo, date_repo = get_sha()
        sha_installed = get_installed_nvim_sha()
        logmsg(f"Nightly tag SHA: {sha_repo}, Installed: {sha_installed}")

        if sha_repo == sha_installed:
            logmsg("Already up to date with nightly. No upgrade needed.")
            print("Already up to date with nightly. No upgrade needed.")
            return

        if sha_installed:
            if not backup_nvim(sha_installed):
                logerr("Backup failed! Aborting upgrade.")
                print("Backup failed! Aborting upgrade.", file=sys.stderr)
                return

        remove_build()
        build_and_install()

        logmsg(f"Upgrade complete: {date_repo=} {sha_repo=}")
        add_history_entry(
            date_repo, sha_repo, "upgrade_from_" + (sha_installed or "none")
        )
        print(f"Upgraded from {sha_installed} to {sha_repo} (nightly)")

    except Exception as e:
        logexc(e)
        print("Upgrade failed. See log for details.", file=sys.stderr)
        sys.exit(1)


def rollback():
    try:
        h = prev_history()
        if not h:
            print("No previous version in history. Can't rollback!")
            return
        target_sha = h["sha"]
        logmsg(f"Rolling back to {target_sha} ({h['tag']}) ...")
        restore_nvim(target_sha)
        add_history_entry(h["tag"], h["sha"], "rollback")
        print(f"Rolled back to {target_sha} ({h['tag']})")
    except Exception as e:
        logexc(e)
        print("Rollback failed. See log for details.", file=sys.stderr)
        sys.exit(1)


def show_version():
    sha, date = get_sha()
    installed_sha = get_installed_nvim_sha()
    remote_nightly_sha = get_remote_nightly_sha()

    print(f"Repo HEAD: date={date}, sha={sha}")
    print(f"Installed nvim: sha={installed_sha}")
    if remote_nightly_sha:
        print(f"Remote nightly: sha={remote_nightly_sha}")

    if not installed_sha:
        print("Could not determine installed version.")
        return

    if not remote_nightly_sha:
        print("Could not determine remote nightly version.")
        return

    if remote_nightly_sha == installed_sha:
        print("You are on the latest nightly version.")
    else:
        try:
            # Count commits between installed and remote nightly
            count = run(
                [
                    "git",
                    "rev-list",
                    "--count",
                    f"{installed_sha}..{remote_nightly_sha}",
                ],
                capture_output=True,
            )
            if count and int(count) > 0:
                print(f"You are {count} commits behind the latest nightly version.")
            else:
                # Installed might be ahead or on a different branch
                print("Your installed version differs from the latest nightly.")
        except Exception:
            print("Could not determine how far behind you are.")


def show_logfile():
    print(str(LOG_FILE))


def manual_checkout(sha):
    try:
        logmsg(f"Checking out {sha} ...")
        git_checkout(sha)
        remove_build()
        build_and_install()
        sha_new, date_new = get_sha()
        add_history_entry(date_new, sha_new, "manual_checkout")
        print(f"Checked out {date_new} ({sha_new})")
    except Exception as e:
        logexc(e)
        print("Manual checkout failed. See log for details.", file=sys.stderr)
        sys.exit(1)


# --- CLI ---
def main():
    parser = ArgumentParser(description="Advanced Neovim Source Upgrade Manager.")
    parser.add_argument(
        "--upgrade", action="store_true", help="Upgrade to latest upstream version."
    )
    parser.add_argument(
        "--rollback",
        action="store_true",
        help="Roll back to previous version by history.",
    )
    parser.add_argument(
        "--history",
        action="store_true",
        help="Print recorded upgrade/rollback history.",
    )
    parser.add_argument(
        "--version", action="store_true", help="Print current tag and commit SHA."
    )
    parser.add_argument(
        "--logfile", action="store_true", help="Show most recent logfile path."
    )
    parser.add_argument(
        "--checkout", metavar="SHA", help="Manually check out a specific SHA"
    )

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(0)

    os.chdir(NVIM_SRC)

    args = parser.parse_args()
    if args.upgrade:
        upgrade()
    elif args.rollback:
        rollback()
    elif args.history:
        print_history()
    elif args.version:
        show_version()
    elif args.logfile:
        show_logfile()
    elif args.checkout:
        manual_checkout(args.checkout)


if __name__ == "__main__":
    main()
