#compdef groot goToGroot cst gibid gibidp gignore searchGitLogs gst gstat ga gaa gc gci gempty gca gcan gcaa gco gcb gd gds gdh gf gfo gu gup gp gpf gpff gpt gsup grh grhh grs gsh gl glog gac gacp gfapu gcbft gcbfx gcbch gcbrf gcbdc gcbst gcbts gr gra grr grs fcom fgdiff fgsearch grsu

# Load git completion cache system
autoload -Uz "${0:h}/_git_cache_system" 2>/dev/null || true

# Function to provide smart argument completion for git functions
function _git_core_complete_args() {
  local cmd="$1"
  
  # Only provide argument completion if we're in a git repo and beyond the first argument
  if (( CURRENT > 1 )) && git rev-parse --git-dir &>/dev/null 2>&1; then
    case "$cmd" in
      gco|gcb|grb|gm|pullBranchThenRebaseWithIt|gpmm|gprm|pullMasThenRebaseWithIt)
        # These functions take branch names as arguments
        local -a branches
        
        # Use simple git command for branch completion
        while IFS= read -r branch; do
          [[ -n "$branch" ]] || continue
          branches+=("$branch")
        done < <(git branch --format='%(refname:short)' 2>/dev/null)
        
        if (( ${#branches[@]} > 0 )); then
          _describe 'git branches' branches
          return 0
        fi
        ;;
      gsup)
        # Set upstream - suggest remote/branch format
        local current_branch
        current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [[ -n "$current_branch" ]]; then
          local -a remotes
          remotes=($(git remote 2>/dev/null))
          if (( ${#remotes[@]} > 0 )); then
            local -a upstream_options
            for remote in "${remotes[@]}"; do
              upstream_options+=("$remote/$current_branch")
            done
            _describe 'upstream branches' upstream_options
            return 0
          fi
        fi
        ;;
      grsu)
        # Remote set upstream - complete remote names, then branches
        if (( CURRENT == 2 )); then
          local -a remotes
          remotes=($(git remote 2>/dev/null))
          if (( ${#remotes[@]} > 0 )); then
            _describe 'remotes' remotes
            return 0
          fi
        elif (( CURRENT == 3 )); then
          local current_branch
          current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
          if [[ -n "$current_branch" ]]; then
            _describe 'branch name' "$current_branch:current branch"
            return 0
          fi
        fi
        ;;
      grr|grs)
        # Remove/set remote - complete with existing remote names
        if (( CURRENT == 2 )); then
          local -a remotes
          remotes=($(git remote 2>/dev/null))
          if (( ${#remotes[@]} > 0 )); then
            _describe 'remotes' remotes
            return 0
          fi
        fi
        ;;
    esac
  fi
  
  # No specific argument completion available
  return 1
}

# Main completion function
function _git_core() {
  local -a git_commands
  git_commands=(
    'groot:Get git repository root path'
    'goToGroot:Change to git repository root'
    'cst:Clear terminal and show git status'
    'gibid:Commit all changes and amend without editing'
    'gibidp:Amend and force push with lease'
    'gignore:Edit global gitignore file'
    'searchGitLogs:Search git log for code changes'
    'gst:Show git status with short format'
    'gstat:Show full git status'
    'gl:Show git log with graph'
    'glog:Show detailed git log with colors'
    'gsh:Show commit details'
    'ga:Add files to git index'
    'gaa:Add all files to git index'
    'gc:Commit with message'
    'gci:Interactive commit with editor'
    'gempty:Create empty commit'
    'gca:Amend last commit with editor'
    'gcan:Amend last commit without editing'
    'gcaa:Amend last commit with all changes'
    'gco:Checkout branch or commit'
    'gcb:Create and checkout new branch'
    'gcbft:Create feat/ branch'
    'gcbfx:Create fix/ branch'
    'gcbch:Create chore/ branch'
    'gcbrf:Create refactor/ branch'
    'gcbdc:Create docs/ branch'
    'gcbst:Create style/ branch'
    'gcbts:Create test/ branch'
    'gd:Show working tree diff'
    'gds:Show staged diff'
    'gdh:Show diff against HEAD'
    'gf:Fetch all remotes with prune'
    'gfo:Fetch origin with prune'
    'gu:Pull with rebase'
    'gup:Pull without rebase'
    'gp:Push current branch'
    'gpf:Push with force-with-lease'
    'gpff:Force push (dangerous)'
    'gpt:Push tags'
    'gsup:Set upstream for current branch'
    'grsu:Set upstream to remote'
    'grh:Reset HEAD (unstage files)'
    'grhh:Hard reset HEAD (dangerous)'
    'grs:Restore files'
    'gr:List all remotes'
    'gra:Add remote'
    'grr:Remove remote'
    'gac:Add and commit'
    'gacp:Add, commit, and push'
    'gfapu:Fetch all and pull with rebase'
    'fcom:Browse and checkout commits'
    'fgdiff:Compare branches with file diffs'
    'fgsearch:Search commits with filters'
  )

  # If no arguments yet, show command descriptions for zh help system
  if (( CURRENT == 1 )); then
    _describe 'git core commands' git_commands
  else
    # Try to provide smart argument completion
    local cmd="$words[1]"
    if ! _git_core_complete_args "$cmd"; then
      # Fallback to showing commands if no specific completion available
      _describe 'git core commands' git_commands
    fi
  fi
}

# The #compdef directive at the top automatically registers this function