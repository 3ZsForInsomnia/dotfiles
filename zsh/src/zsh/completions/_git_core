#compdef groot goToGroot cst gibid gibidp gignore searchGitLogs gst gstat ga gaa gc gci gempty gca gcan gcaa gco gcb gbd gbD gd gds gdh gf gfo gu gup gp gpf gpff gpt gsup grh grhh grs gsh gl glog gac gacp gaczp gfapu gcbft gcbfx gcbch gcbrf gcbdc gcbst gcbts gr gra grr grs fcom fgdiff fgsearch grsu

# Load git completion cache system
autoload -Uz "${0:h}/_git_cache_system" 2>/dev/null || true

# Function to provide smart argument completion for git functions
function _git_core_complete_args() {
  local cmd="$1"
  
  # Only provide argument completion if we're in a git repo and beyond the first argument
  if (( CURRENT > 1 )) && git rev-parse --git-dir &>/dev/null 2>&1; then
    case "$cmd" in
      ga|gaa|gac|gacp|gaczp)
        # git add commands - complete with modified and untracked files
        # Handle different argument positions for different functions
        case "$cmd" in
          gac)
            # gac <message> [files] - first arg is message, subsequent are files
            if (( CURRENT == 2 )); then
              _message "commit message"
              return 0
            elif (( CURRENT > 2 )); then
              # Complete with files for additional arguments
              local -a modified_files untracked_files all_files
              
              # Get modified files (both staged and unstaged)
              while IFS= read -r file; do
                [[ -n "$file" ]] || continue
                modified_files+=("${file}:modified")
              done < <(git diff --name-only HEAD 2>/dev/null)
              
              # Get untracked files
              while IFS= read -r file; do
                [[ -n "$file" ]] || continue
                untracked_files+=("${file}:untracked")
              done < <(git ls-files --others --exclude-standard 2>/dev/null)
              
              # Combine arrays
              all_files=("${modified_files[@]}" "${untracked_files[@]}")
              
              if (( ${#all_files[@]} > 0 )); then
                _describe 'files' all_files
              else
                _files
              fi
            fi
            ;;
          gacp)
            # gacp <message> [files] - first arg is message, subsequent are files
            if (( CURRENT == 2 )); then
              _message "commit message"
              return 0
            elif (( CURRENT > 2 )); then
              # Complete with files for additional arguments
              local -a modified_files untracked_files all_files
              
              # Get modified files (both staged and unstaged)
              while IFS= read -r file; do
                [[ -n "$file" ]] || continue
                modified_files+=("${file}:modified")
              done < <(git diff --name-only HEAD 2>/dev/null)
              
              # Get untracked files
              while IFS= read -r file; do
                [[ -n "$file" ]] || continue
                untracked_files+=("${file}:untracked")
              done < <(git ls-files --others --exclude-standard 2>/dev/null)
              
              # Combine arrays
              all_files=("${modified_files[@]}" "${untracked_files[@]}")
              
              if (( ${#all_files[@]} > 0 )); then
                _describe 'files' all_files
              else
                _files
              fi
            fi
            ;;
          gaczp)
            # gaczp [-r] [-n] [files] - complete with files
            local -a modified_files untracked_files all_files
            
            # Get modified files (both staged and unstaged)
            while IFS= read -r file; do
              [[ -n "$file" ]] || continue
              modified_files+=("${file}:modified")
            done < <(git diff --name-only HEAD 2>/dev/null)
            
            # Get untracked files
            while IFS= read -r file; do
              [[ -n "$file" ]] || continue
              untracked_files+=("${file}:untracked")
            done < <(git ls-files --others --exclude-standard 2>/dev/null)
            
            # Combine arrays
            all_files=("${modified_files[@]}" "${untracked_files[@]}")
            
            if (( ${#all_files[@]} > 0 )); then
              _describe 'files' all_files
            else
              _files
            fi
            ;;
          ga|gaa)
            # ga/gaa [files] - always file completion
            local -a modified_files untracked_files all_files
            
            # Get modified files (both staged and unstaged)
            while IFS= read -r file; do
              [[ -n "$file" ]] || continue
              modified_files+=("${file}:modified")
            done < <(git diff --name-only HEAD 2>/dev/null)
            
            # Get untracked files
            while IFS= read -r file; do
              [[ -n "$file" ]] || continue
              untracked_files+=("${file}:untracked")
            done < <(git ls-files --others --exclude-standard 2>/dev/null)
            
            # Combine arrays
            all_files=("${modified_files[@]}" "${untracked_files[@]}")
            
            if (( ${#all_files[@]} > 0 )); then
              _describe 'files' all_files
            else
              # Fallback to regular file completion if no git-specific files
              _files
            fi
            ;;
        esac
        return 0
        ;;
      gc)
        # git commit - only takes a commit message
        if (( CURRENT == 2 )); then
          _message "commit message"
          return 0
        fi
        ;;
      gd|gdh)
        # git diff commands - complete with modified files (working tree)
        local -a modified_files
        
        while IFS= read -r file; do
          [[ -n "$file" ]] || continue
          modified_files+=("${file}:modified")
        done < <(git diff --name-only 2>/dev/null)
        
        if (( ${#modified_files[@]} > 0 )); then
          _describe 'modified files' modified_files
        else
          _files
        fi
        return 0
        ;;
      gds)
        # git diff --staged - complete with staged files
        local -a staged_files
        
        while IFS= read -r file; do
          [[ -n "$file" ]] || continue
          staged_files+=("${file}:staged")
        done < <(git diff --staged --name-only 2>/dev/null)
        
        if (( ${#staged_files[@]} > 0 )); then
          _describe 'staged files' staged_files
        else
          _files
        fi
        return 0
        ;;
      grs)
        # git restore - complete with modified files (working tree)
        local -a modified_files
        
        while IFS= read -r file; do
          [[ -n "$file" ]] || continue
          modified_files+=("${file}:modified")
        done < <(git diff --name-only 2>/dev/null)
        
        if (( ${#modified_files[@]} > 0 )); then
          _describe 'modified files' modified_files
        else
          _files
        fi
        return 0
        ;;
      grh)
        # git reset HEAD - complete with staged files
        local -a staged_files
        
        while IFS= read -r file; do
          [[ -n "$file" ]] || continue
          staged_files+=("${file}:staged")
        done < <(git diff --staged --name-only 2>/dev/null)
        
        if (( ${#staged_files[@]} > 0 )); then
          _describe 'staged files' staged_files
        else
          _files
        fi
        return 0
        ;;
      gco|gcb|grb|gm|pullBranchThenRebaseWithIt|gpmm|gprm|pullMasThenRebaseWithIt)
        # These functions take branch names as arguments
        local -a branches
        
        # Use simple git command for branch completion
        while IFS= read -r branch; do
          [[ -n "$branch" ]] || continue
          branches+=("$branch")
        done < <(git branch --format='%(refname:short)' 2>/dev/null)
        
        if (( ${#branches[@]} > 0 )); then
          _describe 'git branches' branches
          return 0
        fi
        ;;
      gbd|gbD)
        # Branch deletion functions - complete with local branches only
        local -a branches current_branch
        current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        
        # Get local branches, excluding current branch for safety
        while IFS= read -r branch; do
          [[ -n "$branch" ]] || continue
          # Skip current branch to prevent accidental deletion
          [[ "$branch" != "$current_branch" ]] && branches+=("$branch")
        done < <(git branch --format='%(refname:short)' 2>/dev/null)
        
        if (( ${#branches[@]} > 0 )); then
          _describe 'local branches (excluding current)' branches
          return 0
        fi
        ;;
      gsup)
        # Set upstream - suggest remote/branch format
        local current_branch
        current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [[ -n "$current_branch" ]]; then
          local -a remotes
          remotes=($(git remote 2>/dev/null))
          if (( ${#remotes[@]} > 0 )); then
            local -a upstream_options
            for remote in "${remotes[@]}"; do
              upstream_options+=("$remote/$current_branch")
            done
            _describe 'upstream branches' upstream_options
            return 0
          fi
        fi
        ;;
      grsu)
        # Remote set upstream - complete remote names, then branches
        if (( CURRENT == 2 )); then
          local -a remotes
          remotes=($(git remote 2>/dev/null))
          if (( ${#remotes[@]} > 0 )); then
            _describe 'remotes' remotes
            return 0
          fi
        elif (( CURRENT == 3 )); then
          local current_branch
          current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
          if [[ -n "$current_branch" ]]; then
            _describe 'branch name' "$current_branch:current branch"
            return 0
          fi
        fi
        ;;
      grr|grs)
        # Remove/set remote - complete with existing remote names
        if (( CURRENT == 2 )); then
          local -a remotes
          remotes=($(git remote 2>/dev/null))
          if (( ${#remotes[@]} > 0 )); then
            _describe 'remotes' remotes
            return 0
          fi
        fi
        ;;
    esac
  fi
  
  # No specific argument completion available
  return 1
}

# Main completion function
function _git_core() {
  local -a git_commands
  git_commands=(
    'groot:Get git repository root path'
    'goToGroot:Change to git repository root'
    'cst:Clear terminal and show git status'
    'gibid:Commit all changes and amend without editing'
    'gibidp:Amend and force push with lease'
    'gignore:Edit global gitignore file'
    'searchGitLogs:Search git log for code changes'
    'gst:Show git status with short format'
    'gstat:Show full git status'
    'gl:Show git log with graph'
    'glog:Show detailed git log with colors'
    'gsh:Show commit details'
    'ga:Add files to git index'
    'gaa:Add all files to git index'
    'gc:Commit with message'
    'gci:Interactive commit with editor'
    'gempty:Create empty commit'
    'gca:Amend last commit with editor'
    'gcan:Amend last commit without editing'
    'gcaa:Amend last commit with all changes'
    'gco:Checkout branch or commit'
    'gcb:Create and checkout new branch'
    'gbd:Delete merged branch (safe)'
    'gbD:Force delete branch (dangerous)'
    'gcbft:Create feat/ branch'
    'gcbfx:Create fix/ branch'
    'gcbch:Create chore/ branch'
    'gcbrf:Create refactor/ branch'
    'gcbdc:Create docs/ branch'
    'gcbst:Create style/ branch'
    'gcbts:Create test/ branch'
    'gd:Show working tree diff'
    'gds:Show staged diff'
    'gdh:Show diff against HEAD'
    'gf:Fetch all remotes with prune'
    'gfo:Fetch origin with prune'
    'gu:Pull with rebase'
    'gup:Pull without rebase'
    'gp:Push current branch'
    'gpf:Push with force-with-lease'
    'gpff:Force push (dangerous)'
    'gpt:Push tags'
    'gsup:Set upstream for current branch'
    'grsu:Set upstream to remote'
    'grh:Reset HEAD (unstage files)'
    'grhh:Hard reset HEAD (dangerous)'
    'grs:Restore files'
    'gr:List all remotes'
    'gra:Add remote'
    'grr:Remove remote'
    'gac:Add and commit'
    'gacp:Add, commit, and push'
    'gaczp:Add, commitizen, and push'
    'gfapu:Fetch all and pull with rebase'
    'fcom:Browse and checkout commits'
    'fgdiff:Compare branches with file diffs'
    'fgsearch:Search commits with filters'
  )

  # If no arguments yet, show command descriptions for zh help system
  if (( CURRENT == 1 )); then
    _describe 'git core commands' git_commands
  else
    # Try to provide smart argument completion
    local cmd="$words[1]"
    if ! _git_core_complete_args "$cmd"; then
      # Fallback to showing commands if no specific completion available
      _describe 'git core commands' git_commands
    fi
  fi
}

# The #compdef directive at the top automatically registers this function
